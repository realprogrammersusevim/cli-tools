#!/usr/bin/env python3

# Some utility functions from https://github.com/my-other-github-account/imessage_tools/blob/master/imessage_tools.py

import argparse
import datetime
import sqlite3
from pathlib import Path


def get_chat_mapping(db_location):
    conn = sqlite3.connect(db_location)
    cursor = conn.cursor()

    cursor.execute("SELECT room_name, display_name FROM chat")
    result_set = cursor.fetchall()

    mapping = {room_name: display_name for room_name, display_name in result_set}

    conn.close()

    return mapping


def read_messages(
    db_location=Path.home() / "Library" / "Messages" / "chat.db",
    n=10,
    self_number="Me",
    human_readable_date=True,
    phone_number=None,
):
    """Read messages, optionally restricted to a single conversation.

    When phone_number is provided, only messages from chats that include
    that handle are selected. Results are streamed from the cursor instead
    of using fetchall() to avoid loading the full DB into memory.
    """
    conn = sqlite3.connect(db_location)
    cursor = conn.cursor()

    # Preload chat display-name mapping once
    mapping = get_chat_mapping(db_location)

    params = []

    if phone_number:
        # Select all messages that belong to any chat that includes the given handle
        query = """
        SELECT m.ROWID, m.date, m.text, m.attributedBody, h.id, m.is_from_me, m.cache_roomnames
        FROM message m
        JOIN chat_message_join cmj ON cmj.message_id = m.ROWID
        JOIN chat c ON c.ROWID = cmj.chat_id
        JOIN chat_handle_join chj ON chj.chat_id = c.ROWID
        JOIN handle h_target ON h_target.ROWID = chj.handle_id
        LEFT JOIN handle h ON m.handle_id = h.ROWID
        WHERE h_target.id = ?
        ORDER BY m.date ASC
        """
        params.append(phone_number)
    else:
        # Fallback: all messages, but still stream and optionally limit
        query = """
        SELECT m.ROWID, m.date, m.text, m.attributedBody, h.id, m.is_from_me, m.cache_roomnames
        FROM message m
        LEFT JOIN handle h ON m.handle_id = h.ROWID
        ORDER BY m.date ASC
        """

    if n is not None:
        query += " LIMIT ?"
        params.append(n)

    cursor.execute(query, tuple(params))

    messages = []

    for result in cursor:
        rowid, date, text, attributed_body, handle_id, is_from_me, cache_roomname = (
            result
        )

        number_or_self = self_number if handle_id is None else handle_id

        if text is not None:
            body = text
        elif attributed_body is None:
            continue
        else:
            attributed_body = attributed_body.decode("utf-8", errors="replace")

            if "NSNumber" in str(attributed_body):
                attributed_body = str(attributed_body).split("NSNumber")[0]
                if "NSString" in attributed_body:
                    attributed_body = str(attributed_body).split("NSString")[1]
                    if "NSDictionary" in attributed_body:
                        attributed_body = str(attributed_body).split("NSDictionary")[0]
                        attributed_body = attributed_body[6:-12]
                        body = attributed_body

        if human_readable_date:
            date_string = "2001-01-01"
            mod_date = datetime.datetime.strptime(date_string, "%Y-%m-%d")
            unix_timestamp = int(mod_date.timestamp()) * 1000000000
            new_date = int((date + unix_timestamp) / 1000000000)
            date = datetime.datetime.fromtimestamp(new_date).strftime(
                "%Y-%m-%d %H:%M:%S"
            )

        mapped_name = mapping.get(cache_roomname)

        messages.append(
            {
                "rowid": rowid,
                "date": date,
                "body": body,
                "phone_number": number_or_self,
                "is_from_me": is_from_me,
                "cache_roomname": cache_roomname,
                "group_chat_name": mapped_name,
            }
        )

    conn.close()
    return messages


parser = argparse.ArgumentParser()
parser.add_argument(
    "-p",
    "--phone-number",
    type=str,
    help="Phone number of other person in conversation",
)
parser.add_argument("-n", "--name", type=str, help="Other persons name")
args = parser.parse_args()

# Stream only the requested conversation (no full-DB load)
messages = read_messages(n=None, phone_number=args.phone_number)

for message in messages:
    if message["is_from_me"] == 1:
        print("**Me**:")
        print(message["body"])
    else:
        print(f"**{args.name}**:")
        print(message["body"])
